\begin{ProjectEuler}[Even Fibonacci numbers]{2}
	Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with $1$ and $2$, the first $10$ terms will be:
	%
	\begin{align*}
		1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \ldots
	\end{align*}
	%
	By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
\end{ProjectEuler}
\begin{pythoncode}
	sum(int(.5+5**(-.5)*(.5+.5*5**.5)**(3*n)) for n in 
	range(100) if int(.5+5**(-.5)*(.5+.5*5**.5)**(3*n)) < 4*10**6)
\end{pythoncode}
This is one of my favourite problems and as a teaser one of the solution can be written as
%
\begin{pythoncode}
	def sum_even_fibonacci(limit):
    	a, b = 0, 2
    	while b < limit:
        	a, b = b, 4 * b + a
    	return (a + b - 2) / 4
\end{pythoncode}
%
However to understand how this code works we have to go pretty far down the rabbit hole. A warning before we start: this problem
is very easy to solve under \SI{1}{s}, and any improvements beyond this is purely for the amusement of the Author. By the end
we will have developed a method to find the sum of all even Fibonacci numbers under $10^{\num{10 000}}$ in about a \SI{1}{\ms}.
\begin{definition}
	the Fibonacci numbers are the numbers in the following integer sequence, called the Fibonacci sequence:
	\kortlinje
	%
	\begin{align*}
		0,\;1,\;1,\;2,\;3,\;5,\;8,\;13,\;21,\;34,\;55,\;89,\;144,\; \ldots
	\end{align*}
	%
	The numbers have in common that each subsequent number is the sum of the previous two. In mathematical terms we can define the Fibonacci numbers as:
	\begin{align}
	\label{eq: P01 F_n=F_n-1+F_n-2}
		F_{n} = F_{n-1} + F_{n-2}
	\end{align}
	with initial conditions $F_0 = 0$ and $F_1 = 1$.
\end{definition}
%
Note that this definition differs slightly from the proposed by Project Euler. The difference is that our indices
is shifted $n \to n+2$ such that $F_{\text{PE} n} = F_{n + 2}$. The  only reason for this is that it leads to slightly nicer notation later on.

The definition above leads us straight into the following code
\begin{pythoncode}
	def fib(n):
        if n < 2:
            return n
        else:
            return fib(n-1) + fib(n-2)
            
	def sum_even_fib_naive(limit):
	    n = total = 0
	    while fib(n) < limit:
	        n += 1
	        if fib(n) % 2 == 0:
	            total += fib(n)
	    return total
\end{pythoncode}
%
This is so far the slowest solution I have yet written to a Project Euler problem. To just see how slow it is we can measure 
the number of times \verb|fib| is called. To evaluate $F_5$ we have to call our function $35$ times! See \cref{fig: PE02-fib5-tree}
for a visualization of this. If you have a bit of sparetime try to see how big this tree gets for $F_6$, and if you 
have a couple of lifetimes to spare you can verify that \verb|f(33)| makes \num{29860703} function calls.
\begin{figure}[h!tbp]
	\centering
	\begin{tikzpicture}[level distance=1cm,
		level 1/.style={sibling distance=6cm},
		level 2/.style={sibling distance=3cm},
	 	level 3/.style={sibling distance=2cm}]
	 	\node {$F_5$}
	    	child {node {$F_4$}
	      		child {node {$F_3$}
					child {node {$F_2$}
						child {node {$F_1$}}
						child {node {$F_0$}}
					}
					child {node {$F_1$}}      
				}
				child {node {$F_2$}
		      		child {node{$F_1$}}
		      		child {node{$F_0$}}
	    		}
	    	}	    
		    child {node {$F_3$}
				child {node {$F_2$}
					child {node {$F_1$}}
					child {node {$F_0$}}
				}
				child {node {$F_1$}}      
		      };
	\end{tikzpicture}
	\caption{Shows the computations needed to evaluate $F_5$.}
	\label{fig: PE02-fib5-tree}
\end{figure}
%
This is the reason our code is so slow, and it can be shown that \verb|fib(n)| grows as $\mathcal{O}(\phi^n)$. Here $\phi$ is the golden ratio and
shortly see how this number plays a role in our calculations. One method to fix the problem with recursively calling our function is
to store the previously calculated values in memory
%
\begin{multicols}{2}
\begin{pythoncode}
	def fib_memo(n):
	    pad = {0:0, 1:1}
	    def func(n):
	        if n not in pad:
	            pad[n] = func(n-1) + func(n-2)
	        return pad[n]
	    return func(n)
\end{pythoncode}
\vfill
\columnbreak
\begin{pythoncode}
	from functools import lru_cache
	
	@lru_cache(maxsize=None)
	def fib(n):
	    if n < 2:
	        return n
	    return fib(n-1) + fib(n-2)
\end{pythoncode}
\end{multicols}
%
\textbf{Note:} If you are using Python 2.7 you need to use \verb|from functools32 import lru_cache| to use \verb|@lru_cache|. Both of
these functions speeds up \verb|sum_even_fib_naive| dramatically. However the drawback of using memoization is that it needs to store
a large number of values and thus is not very memory efficient. In this problem however memory is not a concern since to obtain
the solution we only need to store 32 values in memory. 
%
On the other hand it is a good practice not to hog more memory than needed and in this problem it is easy to do so. \Cref{eq: P01 F_n=F_n-1+F_n-2}
is know as a \emph{second order linear homogeneous recurrence relation}. That was a bit of a mouthful, but it basically means we can find a
closed form for the $n$th Fibonacci number. One way to find the solution to these equations is to simply \emph{guess}. 
You are free to try $f(n) = An + B$, $f(n) = A n^2 + B n + C $ or any other polynomial. However none of these attempts work out. For
recurrence relations our first guess is usually on the form $f(n) = A \cdot P^n$, inserting this in \cref{eq: P01 F_n=F_n-1+F_n-2} gives
%
\begin{align}
	\label{eq: PE02 A(P^n-P^(n-1)-P^(n-2))}
	A \cdot (P^n - P^{n-1} - P^{n-2}) = 0
\end{align}
%
For the relation to hold the left-hand side to be zero for all values of $n$ either $A$ or $P^n - P^{n-1} - P^{n-2}$ has to be zero.
$f(n) = 0$ satisfies $F_n = F_{n-1} - F_{n-2}$, however it is obviously not the solution we are looking for. Hence
we assume that $A \neq 0$, and we can safely divide \cref{eq: PE02 A(P^n-P^(n-1)-P^(n-2))} by $A$. In the same vein we also
multiply the equation by $P^{2-n}$
\begin{align*}
	P^2 - P - 1 = 0
\end{align*}
% 
This is called the \emph{characteristic polynomial} to our recurrence relation. The roots of this equation gives us 
the valid values for $P$ such that $f(n) = A \cdot P^n$ satisfies \cref{eq: P01 F_n=F_n-1+F_n-2}. 
%
\begin{align*}
	P = 0 \vee P = \frac{1 \pm \sqrt{5}}{2}
\end{align*}
%
Again $P = 0$ is the \emph{trivial} solution. I will leave it to you to verify that $f(n) = A [ (1 + \sqrt{5})/2]^n$ satisfies
$f(n) = f(n-1) + f(n-2)$. There is a small problem with our solution however, even though it satisfies the recurrence relation 
the \emph{initial-values} are wrong. We need $f(0)=0$, but then $f(0) = A$, hence $A = 0$ and we are again left with the trivial solution.

For a moment assume that both $f(n) = A P^n$ and $g(n) = B Q^n$ satisfies \cref{eq: P01 F_n=F_n-1+F_n-2}, then $h(n) = A P^n + B Q^n$
will also satisfy the equation. Said more plainly \emph{a sum of solutions is also a solution}. Our next guess therefore becomes
%
\begin{align*}
	f(n) = A \left( \frac{1 + \sqrt{5}}{2} \right)^n + B \left( \frac{1 - \sqrt{5}}{2} \right)^n
\end{align*}
%
What remains is finding $A$, and $B$ such that $f(0) = 0$ and $f(1) = 1$. This leads to the following system of equations
%
\begin{align*}
	A + B = 0 \quad \text{and} \quad 
	A \left( \frac{1 + \sqrt{5}}{2} \right) + B \left( \frac{1 - \sqrt{5}}{2} \right) = 0
\end{align*}
%
Solving this system is quite trivial and yields $A = 1/\sqrt{5}$ and $B = -A = -1/\sqrt{5}$. 
%
\begin{align*}
	F_n = \frac{1}{\sqrt{5}} \left( \frac{1 + \sqrt{5}}{2} \right)^n - \frac{1}{\sqrt{5}} \left( \frac{1 - \sqrt{5}}{2} \right)^n
\end{align*}
%
This equation can be written in a varity of ways and I have collected a handful below
\begin{align}
\label{eq: PE02 closed-form-fibonacci}
	   F_n 
	= \frac{\phi^n - \psi^n}{\phi - \psi} 
	= \frac{\phi^n - \psi^n}{\sqrt{5}}
	= \frac{\phi^n - (-\phi)^{-n}}{\sqrt{5}}
\end{align}
The notation $\phi = (1 + \sqrt{5})/2$ and $\psi = (1 - \sqrt{5})/2$ was used for convenience sake\footnote{Know as the golden ratio}.
Proving the last relation implies proving $\psi = -1/\phi \ \Longrightarrow \ \psi^n = (-1/\phi)^n = \phi^{-n}$ is left as a small exercise.  
The implications this has is that $(-\phi)^{-n}$ quickly diminishes $(-\phi)^{-10} \approx \num{0.00813}$. Hence we can implement the $F_n$
function as $F_n = \text{ceil}( \phi^n / \sqrt{5})$.
%
\begin{pythoncode}
	SQRT_5 = 5**0.5
	PHI = 0.5*(1 + SQRT_5)
	def fib_exact(n):
	    return int(0.5 + (PHI**n)/SQRT_5)
\end{pythoncode}
%
Where \verb|int(0.5+num)| was used to round up, since $\text{floor}(x+0.5) = \text{ceil}(x)$. At a first glance this seems like the perfect solution
as it runs in constant running time and for our problem it works without quirks. However exponentiation with decimal numbers is very prone to rounding errors.
Checking the accuracy of this function one can see that it starts deviates from the actual Fibonacci numbers after $n = 71$. 
For now I present an alternative. The following code is a simple exact way to generate the fibonacci numbers without relying on recursion nor memoization. 
%
\begin{multicols}{2}
\begin{pythoncode}
	def fib_generator():
	    F0, F1 = 0, 1
	    while True:
	        yield F0
	        F1, F0 = F1 + F0, F1
\end{pythoncode}
\vfill
\columnbreak
\begin{pythoncode}
def sum_even_fibbonaci(limit):
    total = 0
    for nth_fib in fib_generator():
        if nth_fib % 2 != 0: continue
        if nth_fib > limit: return total
        total += nth_fib
\end{pythoncode}
\end{multicols}
Even though the closed form could not be used our efforts have not been completely wasted. \Cref{eq: PE02 closed-form-fibonacci} gives
us an excellent starting point in figuring out how many terms we need. At first glance this seems complicated and for complete accuracy 
we should use a numerical method such as Newton-rhapson or the bisection method. However since $(-\phi)^{-n}$ diminishes so quickly a
 rough solution is just to ignore it. 
\begin{align*}
	M = F_{3n} 
	\ \Rightarrow \ 
	M \approx \frac{\phi^{3n}}{\sqrt{5}}
	\ \Rightarrow \
	n \approx \frac{1}{6} \log_\phi(5) + \frac{1}{3} \log_\phi(M)
\end{align*}
 %
Where $M$ denotes the largest $F_n$ we will allow. For every $M > 1$ the approximation is equal to the actual value rounded down. 
%
\begin{pythoncode}
	from math import log

	PHI = (1 + 5**0.5)/float(2)
	LOG_5 = log(5, PHI)/float(6)
	
	def largest_even_fib_index(n):
	    return int(LOG_5 + log(n, PHI)/float(3))
	
	def sum_even_fibbonaci_w_end(M):
	    F0, F1, total = 0, 1, 0
	    for _ in range(largest_even_fib_index(M)):
	        for _ in range(3):
	            F1, F0 = F1 + F0, F1
	        total += F0
	    return total
\end{pythoncode}
%
Note that even after all these efforts the running time of our algorithm is still the same. 
By writing out the first Fibonacci numbers we can see a pattern start to form
%
\begin{align*}
	\mathbf{0},   \; 1,     \; 1,  \; 
	\mathbf{2},   \; 3,     \; 5,  \; 
	\mathbf{8},   \; 13,    \; 21, \; 
	\mathbf{34} , \; 55,    \; 89, \; 
	\mathbf{144}, \; \ldots
\end{align*}
%
It seems that every third Fibonacci number is divisible by 3. We can write a short proof using induction to verify this suspicion.
We want to prove that $F_{3n}$ is divisible by $2$ for every $k \geq 0$.
%
\begin{proof}
The base case is that $F_0$ is divisible by $2$, which it is since $F_0 = 0$. 
Assume that there exists some $k$ such that $F_{3k}$ is divisible by $2$. We have to prove that this
implies that $F_{3(k+1)} = F_{3k+3}$ is divisible by $2$. 
%
\begin{align}
	\label{eq: PE02 F_3(k+1))=F_3k+2F_(3k+1)}
	F_{3+3k} = F_{2+3k} + F_{1+3k} 
			 = \left[ F_{3k+1} + F_{3k}  \right] + F_{3k+1} 
			 = F_{3k} + 2 F_{3k+1}
\end{align}
%
Where \cref{eq: PE02 F_n=F_n-1+F_n-2} wss used twice.
Since $F_{3k}$ is divisible by $2$ from the induction hypothesis and $2 F_{3+3k}$ is clearly divisible by $2$, the claim follows by induction.
\end{proof}
%
Since there is a closed form for the Fibonacci numbers, it is not unreasonable to think that there exists a similar
pattern for the even Fibonacci numbers, but how can we discover such a pattern? \Cref{eq: PE02 F_3(k+1))=F_3k+2F_(3k+1)}
gives us a starting point, since it has a relation between two even Fibonacci numbers: $F_{3(k+1}$ and $F_3k$. The
only thing that remains is to rewrite $2 F_{3k+1}$ as a sum of even Fibonacci numbers.
%
\begin{align*}
	    2F_{3k+1} 
	& = 2(F_{3k} + F_{3k-1}) \\
	& = 2F_{3k} + 2 F_{3k-1} \\
	& = 2F_{3k} + F_{3k-1} + F_{3k-2} + F_{3k-3} \\
	& = 3F_{3k} + F_{3(k-1)}
\end{align*}
%
Replacing $2 F_{3k+1}$ with $3 F_{3k} + F_{3(k-1)}$ in \cref{eq: PE02 F_3(k+1))=F_3k+2F_(3k+1)} gives us the following relation
\begin{align}
	\label{eq: PE02 F_3(k+1))=4F_3k+2F_3(k-1)}
	F_{3(k+1} = 4 F_{3k} + F_{3(k-1)}
\end{align}
This can also be written as $E(n) = 4 E(n-1) + E(n-2)$ when we let $E(n)$ denote the $n$th even Fibonacci number.
Interestingly enough \cref{eq: PE02 F_3(k+1))=4F_3k+2F_3(k-1)} also holds for the odd Fibonacci numbers, and 
one can prove that $F_n = 4F_{n-3} + F_{n-6}$ holds for every $n$. This however will be left as an exercise for the reader.
%
\begin{pythoncode}
	def sum_even_fast(limit):
	    a, b = 0, 2
	    total = 0
	    while b < limit:
	        total += b
	        a, b = b, 4 * b + a
	    return total
\end{pythoncode}
%
This code is much faster than our previous attempts, and could further be slightly optimized 
by using \verb|for _ in range(largest_even_fib_index(M)):| instead of \verb|while b < limit:|.

The next optimization is to find a closed form for the sum of the first n Fibonacci numbers. 
%
\begin{proposition}
	\begin{align*}
		  \sum_{i=0}^n F_{3i} 
		= \frac{F_{3n+2}-1}{2}
		= \frac{F_{3n} + F_{3n+2} - 2}{4}
	\end{align*}
\end{proposition}
%
\begin{proof}
	We will prove the first relation by induction, while the second is left as an excercise. 
	Base case: $F_{3\cdot0} = 0$ and $(F_{0+2}-1)/2 = 0$. Assume that 
	for some $k$ we have $\sum_{i=0}^k F_{3i} = \frac{F_{3k+2}-1}{2}$. We want to prove 
	that this implies that $\sum_{i=0}^{k+1} F_{3i} = \frac{F_{3(k+1)+2}-1}{2}$ holds. 
	\begin{align*}
		    \sum_{i=0}^{k+1} F_{3i}
		  = F_{3(k+1)} + \sum_{i=0}^{k} F_{3i} 
		& = F_{3(k+1)} + \frac{F_{3k+2}-1}{2} \ \leftarrow \ \text{used the induction hypothesis} \\
		& = \frac{F_{3(k+1)} + F_{3k+3} + F_{3k+2} - 1}{2} 
		  = \frac{F_{3(k+1)} + F_{3(k+1)+1} + - 1}{2} 
		  = \frac{F_{3(k+1)+2}-1}{2}
	\end{align*}
Since $F_{3k+3} + F_{3(k+1)}$ and $F_{3k+2} + F_{3k+3}=F_{3k+4}=F_{3(k+1)+1}$, this concludes the proof.
\end{proof}
%
\begin{pythoncode}
	def constant_even_fib(limit):
	    n = largest_even_fib_under_n(limit)
	    return (int(0.5+PHI**(3*n+2)/5**0.5)-1)/2
\end{pythoncode}
%
This is a rather neat code, however it still suffers from floating point errors, when the powers get too high.
Another solution is to find a closed formula for $E_n = 4 E_{n-1} + E_{n-2}$. Similar as we did in equation nigga we can guess that
$E_n = A \cdot P^n + B \cdot Q^n$, where $P$ and $Q$ are the roots of the characteristic polynomial $x^2 - 4x -1 = (x-2)^2 -5$. 
%
\begin{align*}
	E_n = A (2 + \sqrt{5})^n + B (2 - \sqrt{5})^n
\end{align*}
%
As before we can find the constants using $E_0 = 0$ and $E_1 = 2$.
%
\begin{align*}
	     E_n 
	& = \frac{1}{\sqrt{5}} (2 + \sqrt{5})^n - \frac{1}{\sqrt{5}} (2 - \sqrt{5})^n \\
	    \frac{E_n + E_{n+1}-2}{4}
	& = \frac{1}{4}\left( \frac{1}{\sqrt{5}} (2 + \sqrt{5})^n  + \frac{1}{\sqrt{5}} (2 + \sqrt{5})^{n+1}  - 2 \right) 
	  = \frac{1}{4\sqrt{5}} ( 3 + \sqrt{5} ) (2 + \sqrt{5})^{n} - \frac{1}{2}
\end{align*}
%
Since $\left| (2 - \sqrt{5})^n \right| < 1/2$ for all $n>1$, we only need to add the powers of $2 + \sqrt{5}$.
%
\begin{pythoncode}
def fib_sum_even_constant(limit):
    n = largest_even_fib_under_n(limit)
    return int(.5+5**(-.5)*(3+5**.5)*(2 + 5**.5)**n)/4
\end{pythoncode}
%
Which of these two algorithms if any do you think performs the best? Note that the \verb|-0.5| 
was dropped again because how Python performs rounding. This concludes how far we can go in constant time,
however we are not quite at the end of the road.
%
\subsection{Fibonacci in sublinear time}

If we want to generate the first $n$ Fibonacci numbers the fastest we 
can do is in polynomial time $\mathcal{O}(n)$. This is only natural since we have to iterate over every element.
%
However as we will see if we are only interested in a particular $F_n$ we do not need to generate
every $F_i$ where $0 \leq i \leq k$. There are many different ways to achieve this, I will briefly show three algorithms.

There have been many smaller improvements on the Lucas numbers and the matrix multiplication method. 
One is credited to \citeauthor{Takahashi} which proposed the following algorithm. 
%
\begin{pythoncode}
	def fib_takahashi(n):
	    if n == 0:
	        return n
	    F, L, sign, exp = 1, 1, -2, int(log (n,2))
	    mask = 2**exp
	    for i in xrange (exp - 1):
	        mask = mask >> 1
	        F2   = F**2
	        FL2  = (F + L)**2
	        F    = ((FL2 - 6*F2) >> 1) - sign
	        if n & mask:
	            temp = (FL2 >> 2 ) + F2
	            L     = temp + (F << 1)
	            F     = temp
	        else:
	            L    = 5*F2 + sign
	        sign = -2 if n & mask else 2
	    if n & (mask >> 1) == 0:
	        return F * L
	    else:
	        return ((F + L) >> 1) * L - (sign >> 1)
\end{pythoncode}
%
I will not go into details on how the code works as this is explained much better than I can in his paper, see \cite{Takahashi}.

\bibliographystyle{plainnat}
\bibliography{../REFF}